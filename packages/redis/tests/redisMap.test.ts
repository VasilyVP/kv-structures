import { describe, it, test, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { RedisMap } from "../src/RedisMap.ts";
import { createClient, closeClient } from '../src/init.ts';


const mapName = "testRedisMap";

beforeAll(async () => {
    await createClient();
});

beforeEach(async () => {
    const map = new RedisMap(mapName);
    await map.clear();
});

afterAll(async () => {
    const map = new RedisMap(mapName);
    await map.clear();

    await closeClient();
});

describe("RedisMap", () => {
    it("should be defined when name is autogenerated", () => {
        const map = new RedisMap();
        expect(map).toBeDefined();
    });

    it("should be defined when name is provided", () => {
        const map = new RedisMap(mapName);
        expect(map).toBeDefined();
        expect(map.name).toBe(mapName);
    });

    it("returns a value which was set including ttl options and then delete", async () => {
        const map = new RedisMap(mapName);
        await map.set("key", "value");
        const value = await map.get("key");
        expect(value).toBe("value");

        await map.delete("key");
        const valueDeleted = await map.get("key");
        expect(valueDeleted).toBeNull();

        await map.set("key", "value", 200);
        const has1 = await map.has("key");
        expect(has1).toBe(true);

        const value2 = await map.get("key");
        expect(value2).toBe("value");

        await new Promise((resolve) => setTimeout(resolve, 250));

        const has2 = await map.has("key");
        expect(has2).toBe(false);

        const value3 = await map.get("key");
        expect(value3).toBeNull();
    });

    it("returns a bigint", async () => {
        const map = new RedisMap(mapName, { useNativeBigInt: true });

        await map.set("key", 12345678901234567890n);
        const value = await map.get("key");
        expect(value).toBe(12345678901234567890n);
    });

    it("returns size and keys", async () => {
        const map = new RedisMap(mapName);

        const elements = 16;
        for (let i = 0; i < elements; i++) {
            await map.set(`key${i}`, `value${i}`);
        }

        const size = await map.size();
        expect(size).toBe(elements);

        // checking with a batch size of 5
        let keys = [];
        for await (const key of map.keys(5)) {
            keys.push(key);
        }

        keys.sort((a, b) => Number(a.slice(3)) > Number(b.slice(3)) ? 1 : -1);
        expect(keys).toEqual(Array.from({ length: elements }, (_, i) => `key${i}`));
    });

    it("clears a Map", async () => {
        const map = new RedisMap(mapName);

        const elements = 33;
        for (let i = 0; i < elements; i++) {
            await map.set(`key${i}`, `value${i}`);
        }

        const size = await map.size();
        expect(size).toBe(elements);

        // checking with a batch size of 4
        await map.clear(4);

        const size2 = await map.size();
        expect(size2).toBe(0);
    });

    test("values and entries", async () => {
        const map = new RedisMap(mapName);

        const elements = 23;
        for (let i = 0; i < elements; i++) {
            await map.set(`key${i}`, i);
        }

        // with a default batch size of 100
        const values: string[] = [];
        for await (const value of map.values()) {
            values.push(value);
        }

        values.sort((a, b) => a > b ? 1 : -1);
        expect(values).toEqual(Array.from({ length: elements }, (_, i) => i));

        // with a batch size of 5
        const values2 = [];
        for await (const value of map.values(5)) {
            values2.push(value);
        }
        values2.sort((a, b) => a > b ? 1 : -1);
        expect(values2).toEqual(Array.from({ length: elements }, (_, i) => i));

        // with a batch size of 3
        const entries = [];
        for await (const entry of map.entries(3)) {
            entries.push(entry);
        }
        entries.sort((a, b) => Number(a[0].slice(3)) > Number(b[0].slice(3)) ? 1 : -1);
        expect(entries).toEqual(Array.from({ length: elements }, (_, i) => [`key${i}`, i]));
    });

    test("forEach method", async () => {
        const map = new RedisMap(mapName);

        const elements = 10;
        for (let i = 0; i < elements; i++) {
            await map.set(`key${i}`, i);
        }

        const entries: [string, number][] = [];
        await map.forEach(async (value, key) => {
            entries.push([key, value]);
        });

        entries.sort((a, b) => Number(a[0].slice(3)) > Number(b[0].slice(3)) ? 1 : -1);
        expect(entries).toEqual(Array.from({ length: elements }, (_, i) => [`key${i}`, i]));
    });

    test("iterator", async () => {
        const map = new RedisMap(mapName);

        const elements = 23;
        for (let i = 0; i < elements; i++) {
            await map.set(`key${i}`, i);
        }

        const entries: [string, number][] = [];
        for await (const entry of map) {
            entries.push(entry);
        }

        entries.sort((a, b) => Number(a[0].slice(3)) > Number(b[0].slice(3)) ? 1 : -1);
        expect(entries).toEqual(Array.from({ length: elements }, (_, i) => [`key${i}`, i]));
    });

    it("incements and decrements values", async () => {
        const map = new RedisMap(mapName);

        await map.set("key", 0);
        await map.increment("key", 1);
        const value = await map.get("key");
        expect(value).toBe(1);

        await map.decrement("key", 1);
        const value2 = await map.get("key");
        expect(value2).toBe(0);

        await map.increment("key", 1.5);
        const value3 = await map.get("key");
        expect(value3).toBe(1.5);

        await map.decrement("key", 1.5);
        const value4 = await map.get("key");
        expect(value4).toBe(0);
    });
});
