import { describe, it, test, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { RedisSet } from "../src/RedisSet.ts";
import { createClient, closeClient } from '../src/init.ts';


const setName = "testRedisSet";

beforeAll(async () => {
    await createClient();
});

beforeEach(async () => {
    const set = new RedisSet(setName);
    await set.clear();
});

afterAll(async () => {
    const set = new RedisSet(setName);
    await set.clear();

    await closeClient();
});

describe("RedisSet", () => {
    it("should be defined when name is autogenerated", () => {
        const set = new RedisSet();
        expect(set).toBeDefined();
    });

    it("should be defined when name is provided", () => {
        const set = new RedisSet(setName);
        expect(set).toBeDefined();
        expect(set.name).toBe(setName);
    });

    it("should set, has and then delete a value", async () => {
        const set = new RedisSet(setName);

        await set.add("value1");
        expect(await set.has("value1")).toBe(true);

        await set.delete("value1");
        expect(await set.has("value1")).toBe(false);
    });

    it("should clear the set", async () => {
        const set = new RedisSet(setName);

        await set.add("value1");
        await set.clear();
        expect(await set.has("value1")).toBe(false);
    });

    it("should return correct size", async () => {
        const set = new RedisSet(setName);
        await set.add("value1");
        await set.add("value2");
        expect(await set.size()).toBe(2);
    });

    it("should return values, keys and entries", async () => {
        const set = new RedisSet(setName);

        await set.add("value1");
        await set.add("value2");
        await set.add("value3");

        const values = [];
        for await (const value of set.values(1)) { // batchSize = 1
            values.push(value);
        }
        expect(values.sort()).toEqual(["value1", "value2", "value3"]);

        const keys = [];
        for await (const key of set.keys()) {
            keys.push(key);
        }
        expect(keys.sort()).toEqual(["value1", "value2", "value3"]);

        const entries = [];
        for await (const entry of set.entries()) {
            entries.push(entry);
        }
        expect(entries.sort()).toEqual([["value1", "value1"], ["value2", "value2"], ["value3", "value3"]]);
    });

    test("forEach", async () => {
        const set = new RedisSet(setName);

        const elements = 16;
        for (let i = 0; i < elements; i++) {
            await set.add(`value${i}`);
        }

        const values: string[] = [];
        await set.forEach(
            async (value) => {
                values.push(value);
            },
            { batchSize: 5 }
        );

        const sortedVals = values.sort((a, b) => Number(a.slice(5)) > Number(b.slice(5)) ? 1 : -1);
        expect(sortedVals).toEqual(Array.from({ length: elements }, (_, i) => `value${i}`));
    });

    test("iterator", async () => {
        const set = new RedisSet(setName);

        const elements = 23;
        for (let i = 0; i < elements; i++) {
            await set.add(`value${i}`);
        }

        const values: string[] = [];
        for await (const value of set) {
            values.push(value);
        }

        const sortedVals = values.sort((a, b) => Number(a.slice(5)) > Number(b.slice(5)) ? 1 : -1);
        expect(sortedVals).toEqual(Array.from({ length: elements }, (_, i) => `value${i}`));
    });

    test("intersection", async () => {
        const setA = new RedisSet("setA");
        const setB = new RedisSet("setB");

        await setA.add("value1");
        await setA.add("value2");
        await setB.add("value2");
        await setB.add("value3");

        const intersection = await setA.intersection(setB);
        expect(await intersection.has("value2")).toBe(true);
        expect(await intersection.size()).toBe(1);

        await setA.clear();
        await setB.clear();
        await intersection.clear();
    });

    test("union", async () => {
        const setA = new RedisSet("setA");
        const setB = new RedisSet("setB");

        await setA.add("value1");
        await setA.add("value2");
        await setB.add("value2");
        await setB.add("value3");

        const union = await setA.union(setB);
        expect(await union.has("value1")).toBe(true);
        expect(await union.has("value2")).toBe(true);
        expect(await union.has("value3")).toBe(true);
        expect(await union.size()).toBe(3);

        await setA.clear();
        await setB.clear();
        await union.clear();
    });

    test("difference", async () => {
        const setA = new RedisSet("setA");
        const setB = new RedisSet("setB");

        await setA.add("value1");
        await setA.add("value2");
        await setB.add("value2");
        await setB.add("value3");

        const difference = await setA.difference(setB);
        expect(await difference.has("value1")).toBe(true);
        expect(await difference.size()).toBe(1);

        await setA.clear();
        await setB.clear();
        await difference.clear();
    });

    test("symmetricDifference", async () => {
        const setA = new RedisSet("setA");
        const setB = new RedisSet("setB");

        await setA.add("value1");
        await setA.add("value2");
        await setB.add("value2");
        await setB.add("value3");

        const symmetricDifference = await setA.symmetricDifference(setB);
        expect(await symmetricDifference.has("value1")).toBe(true);
        expect(await symmetricDifference.has("value3")).toBe(true);
        expect(await symmetricDifference.size()).toBe(2);

        await setA.clear();
        await setB.clear();
        await symmetricDifference.clear();
    });

    test("isSubsetOf", async () => {
        const setA = new RedisSet("setA");
        const setB = new RedisSet("setB");

        await setA.add("value1");
        await setA.add("value2");
        await setB.add("value1");
        await setB.add("value2");
        await setB.add("value3");

        expect(await setA.isSubsetOf(setB)).toBe(true);
        expect(await setB.isSubsetOf(setA)).toBe(false);

        await setA.clear();
        await setB.clear();
    });

    test("isSupersetOf", async () => {
        const setA = new RedisSet("setA");
        const setB = new RedisSet("setB");

        await setA.add("value1");
        await setA.add("value2");
        await setA.add("value3");
        await setB.add("value1");
        await setB.add("value2");

        expect(await setA.isSupersetOf(setB)).toBe(true);
        expect(await setB.isSupersetOf(setA)).toBe(false);

        await setA.clear();
        await setB.clear();
    });

    test("isDisjointFrom", async () => {
        const setA = new RedisSet("setA");
        const setB = new RedisSet("setB");

        await setA.add("value1");
        await setA.add("value2");
        await setB.add("value3");
        await setB.add("value4");

        expect(await setA.isDisjointFrom(setB)).toBe(true);

        await setB.add("value2");
        expect(await setA.isDisjointFrom(setB)).toBe(false);

        await setA.clear();
        await setB.clear();
    });
});
